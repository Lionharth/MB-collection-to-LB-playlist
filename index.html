<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>MB → ListenBrainz</title>
<style>
  body { font-family: system-ui, sans-serif; background:#0f0f14; color:#eee; max-width:900px; margin:28px auto; padding:18px;}
  h1{margin:0 0 12px}
  label{display:block; margin-top:8px; color:#ccc}
  input, button { width:100%; padding:10px; margin:8px 0; background:#1c1c26; color:#fff; border:1px solid #333; border-radius:8px; }
  .row{display:flex; gap:10px}
  .row> *{flex:1}
  button{background:#6b5cff;border:none;font-weight:600;cursor:pointer}
  button[disabled]{background:#444;cursor:default}
  pre{background:#14141c;padding:12px;border-radius:8px;white-space:pre-wrap;font-size:13px;max-height:50vh;overflow:auto}
</style>
</head>
<body>
  <h1>MusicBrainz → ListenBrainz</h1>

  <label>ListenBrainz user token</label>
  <input id="lbToken" placeholder="Paste your ListenBrainz token" />

  <label>MusicBrainz collection ID (public)</label>
  <input id="mbCollection" placeholder="e.g. 4d6c8c24-xxxx-xxxx-xxxx-xxxxxxxx" />

  <label>Playlist name</label>
  <input id="playlistName" value="My albums" />

  <div class="row">
    <div>
      <label>MB delay (ms)</label>
      <input id="mbDelay" type="number" value="1500" />
    </div>
    <div>
      <label>Add chunk size</label>
      <input id="addChunk" type="number" value="100" />
    </div>
  </div>

  <div class="row">
    <button id="runBtn">Create + Append</button>
    <button id="retrySkippedBtn" disabled>Retry skipped</button>
  </div>

  <small>If the server rejects a chunk due to size, lower Add chunk size (e.g. 50). The app will create a playlist and append tracks in chunks.</small>
  <pre id="log"></pre>

<script>
/* CONFIG */
const USER_AGENT = "MB-LB-Playlist/1.0 (example@example.com)";
const PLAYLIST_DELAY_MS = 600;
const CREATE_RETRIES = 3;
const ADD_RETRIES = 3;

const logBox = document.getElementById("log");
const log = m => { logBox.textContent += m + "\n"; logBox.scrollTop = logBox.scrollHeight; };
const sleep = ms => new Promise(r => setTimeout(r, ms));

/* light UA fetch */
async function fetchJsonWithUA(url) {
  const res = await fetch(url, { headers: { "User-Agent": USER_AGENT } });
  if (!res.ok) {
    const text = await res.text().catch(()=>"");
    throw new Error(`HTTP ${res.status} ${text || ""}`);
  }
  return res.json();
}

/* Fetch all releases in the collection (paginated) */
async function fetchAllReleases(collectionId, mbDelay) {
  let offset = 0, limit = 100, out = [];
  while (true) {
    const url = `https://musicbrainz.org/ws/2/collection/${collectionId}/releases?fmt=json&limit=${limit}&offset=${offset}`;
    const data = await fetchJsonWithUA(url);
    if (!data.releases || data.releases.length === 0) break;
    out.push(...data.releases);
    offset += limit;
    await sleep(mbDelay);
  }
  return out;
}

/* Fetch recordings from a release (inc=recordings) */
async function fetchRecordingsFromRelease(release, mbDelay) {
  const url = `https://musicbrainz.org/ws/2/release/${release.id}?inc=recordings&fmt=json`;
  const data = await fetchJsonWithUA(url);
  const recs = [];
  for (const medium of data.media || []) {
    for (const t of medium.tracks || []) {
      if (t.recording?.id) recs.push({ identifier: `https://musicbrainz.org/recording/${t.recording.id}` });
    }
  }
  await sleep(mbDelay);
  return recs;
}

/* Create an empty playlist (JSPF with title + extension.public) and return playlist_mbid from server response */
async function createEmptyPlaylist(token, title) {
  const jspf = {
    playlist: {
      title,
      extension: {
        "https://musicbrainz.org/doc/jspf#playlist": { public: true }
      }
    }
  };

  let attempt = 0;
  while (++attempt <= CREATE_RETRIES) {
    try {
      const res = await fetch("https://api.listenbrainz.org/1/playlist/create", {
        method: "POST",
        headers: {
          "Authorization": `Token ${token}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(jspf)
      });
      const txt = await res.text();
      let parsed = null;
      try { parsed = JSON.parse(txt); } catch(e){ parsed = null; }

      if (!res.ok) throw new Error(`LB ${res.status}: ${txt}`);

      // common implementations return 'playlist_mbid' in the JSON
      const mbid = parsed && (parsed.playlist_mbid || parsed.mbid || parsed.id || parsed.playlist_id || parsed.playlistMbid);
      if (!mbid) {
        // if server returned something else, show it
        log("Create returned: " + JSON.stringify(parsed || txt));
        throw new Error("Could not find playlist MBID in create response");
      }
      return mbid;
    } catch (err) {
      log(`⚠ Create attempt ${attempt} failed: ${err.message}`);
      if (attempt < CREATE_RETRIES) await sleep(400 * attempt);
      else throw err;
    }
  }
}

/* Append a chunk of recordings to playlist via /item/add (JSPF body). offset optional; if omitted, appends to end */
async function appendChunkToPlaylist(token, playlist_mbid, recordingsChunk, offset) {
  // Build JSPF: playlist.track[].identifier is an array
  const jspf = {
    playlist: {
      track: recordingsChunk.map(r => ({ identifier: [ r.identifier ] })),
      extension: {
        "https://musicbrainz.org/doc/jspf#playlist": { public: true }
      }
    }
  };

  // build URL (include offset if given)
  const url = offset === undefined
    ? `https://api.listenbrainz.org/1/playlist/${playlist_mbid}/item/add`
    : `https://api.listenbrainz.org/1/playlist/${playlist_mbid}/item/add/${offset}`;

  let attempt = 0;
  while (++attempt <= ADD_RETRIES) {
    try {
      const res = await fetch(url, {
        method: "POST",
        headers: {
          "Authorization": `Token ${token}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(jspf)
      });
      const txt = await res.text();
      if (!res.ok) throw new Error(`LB ${res.status}: ${txt}`);
      // success
      return txt ? JSON.parse(txt) : { ok: true };
    } catch (err) {
      log(`⚠ Append attempt ${attempt} failed: ${err.message}`);
      if (attempt < ADD_RETRIES) {
        await sleep(300 * attempt + Math.floor(Math.random()*200));
        log(`  retrying append...`);
      } else {
        throw err;
      }
    }
  }
}

/* chunk utility */
function chunkArray(arr, n) {
  const out = [];
  for (let i=0;i<arr.length;i+=n) out.push(arr.slice(i,i+n));
  return out;
}

/* MAIN FLOW */
document.getElementById("runBtn").onclick = async function () {
  const btn = this;
  btn.disabled = true;
  logBox.textContent = "";

  try {
    const token = document.getElementById("lbToken").value.trim();
    const collectionId = document.getElementById("mbCollection").value.trim();
    const playlistName = document.getElementById("playlistName").value.trim() || "Imported Playlist";
    const mbDelay = parseInt(document.getElementById("mbDelay").value, 10) || 1100;
    const addChunk = parseInt(document.getElementById("addChunk").value, 10) || 100;

    if (!token || !collectionId) { log("Missing LB token or MB collection ID"); btn.disabled=false; return; }

    log("Fetching MusicBrainz collection...");
    const releases = await fetchAllReleases(collectionId, mbDelay);
    log(`Found ${releases.length} releases.`);

    // expand to recordings (respecting MB delay)
    let recordings = [];
    log("Expanding albums → tracks (polite, can be slow)...");
    for (const r of releases) {
      try {
        log(`• ${r.title}`);
        const recs = await fetchRecordingsFromRelease(r, mbDelay);
        recordings.push(...recs);
      } catch (err) {
        log(`⚠ Skipped: ${r.title} — ${err.message}`);
      }
    }

    // dedupe
    const seen = new Set();
    const deduped = [];
    for (const rec of recordings) {
      if (!rec?.identifier) continue;
      if (!seen.has(rec.identifier)) { seen.add(rec.identifier); deduped.push(rec); }
    }
    log(`Total recordings after dedupe: ${deduped.length}`);
    if (deduped.length === 0) { log("No recordings found."); btn.disabled=false; return; }

    // 1) create empty playlist and retrieve playlist_mbid
    log("Creating empty playlist...");
    const playlist_mbid = await createEmptyPlaylist(token, playlistName);
    log(`Playlist created, MBID: ${playlist_mbid}`);

    // 2) append in chunks
    const chunks = chunkArray(deduped, addChunk);
    log(`Appending ${deduped.length} recordings in ${chunks.length} chunk(s) (chunk size ${addChunk})...`);
    for (let i=0;i<chunks.length;i++) {
      log(`Appending chunk ${i+1}/${chunks.length} (${chunks[i].length} tracks) ...`);
      await appendChunkToPlaylist(token, playlist_mbid, chunks[i]); // appends to end by default
      log(`✅ Appended chunk ${i+1}`);
      await sleep(PLAYLIST_DELAY_MS);
    }

    log("All chunks appended. Done.");
  } catch (err) {
    log("ERROR:");
    log(err.message || err);
  } finally {
    btn.disabled = false;
  }
};
</script>
</body>
</html>
